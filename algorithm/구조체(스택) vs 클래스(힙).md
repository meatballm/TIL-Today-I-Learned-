# 스택메모리와 힙메모리: 구조체(struct) vs 클래스(class)

## 1. 메모리 영역 구분
- **스택(stack)**
  - 함수 호출 시 지역 변수들이 할당되는 영역
  - LIFO 구조로 할당·해제 비용이 매우 낮음
  - 크기가 제한적(보통 몇 MB)
- **힙(heap)**
  - 동적 할당(`new`, `malloc` 등) 시 사용하는 영역
  - 가비지 컬렉션 또는 수동 해제가 필요
  - 크기가 크지만, 할당·해제 비용이 상대적으로 높음

## 2. 값 형식(Value Type) vs 참조 형식(Reference Type)
|구분|값 형식 (struct 등)|참조 형식 (class 등)|
|:--|:------------------|:---------------------|
|할당 위치|스택 또는 인라인(다른 객체 내부)|힙|
|복사 동작|전체 데이터 복사|참조(포인터) 복사|
|메모리 비용|데이터 크기만큼|객체 크기 + 관리 오버헤드|
|GC 대상|아님|예|

## 3. `struct` vs `class`
- **struct (값 형식)**
  - 선언 예: `public struct Point { public int x, y; }`
  - 할당·복사가 곧 데이터 복사 → 크기가 작을수록 효율적
  - 기본값(매우 간단한 형태)이거나 불변(immutable) 타입에 적합
- **class (참조 형식)**
  - 선언 예: `public class Player { public string Name; }`
  - `new` 키워드로 힙에 할당 → 참조 전달
  - 복사 시 포인터만 복사 → 대형 객체를 다룰 때 메모리/성능 효율적

## 4. 박싱(Boxing)·언박싱(Unboxing)
- **박싱**: 값 형식 → `object`(또는 인터페이스)로 변환할 때
  - 스택의 값을 힙에 복사
  - 런타임 비용(메모리 할당 + 가비지) 발생
- **언박싱**: `object` → 값 형식으로 변환
  - 힙에 있는 값을 다시 스택 영역으로 복사

```csharp
int i = 123;         // 스택에 4바이트 할당
object o = i;        // 박싱: 힙에 새로운 객체 할당
int j = (int)o;      // 언박싱: 값을 다시 복사
```

## 5. 언제 `struct`를 사용할까?
1. **작고 불변**
   - 크기가 16바이트 이하이고, 생성 후 값이 변하지 않을 때
2. **빈번한 생성/해제**
   - 스택 할당 덕분에 GC 부담이 없을 때
3. **성능 민감**
   - 짧은 수명·간단 구조체를 다수 생성해야 할 때

> 💡 **주의**:
> - 너무 큰 `struct`(예: 수백 바이트)는 스택 오버플로우 또는 복사 비용 증가를 초래
> - 인터페이스로 캐스팅 시 반드시 박싱 발생 → 오히려 성능 저하
